/* Jungo Connectivity Confidential. Copyright (c) 2020 Jungo Connectivity Ltd.  https://www.jungo.com */

/************************************************************************
*  File: my_driver_diag.c
*
*  Sample user-mode diagnostics application for accessing MY_DRIVER
*  devices, possibly via a Kernel PlugIn driver using WinDriver's API.
*  Code was generated by DriverWizard v14.4.0
*
*  Note: This code sample is provided AS-IS and as a guiding sample only.
*************************************************************************/

#include "wds_lib.h"

#include "utils.h"
#include "status_strings.h"
#include "samples/shared/diag_lib.h"
#include "samples/shared/wdc_diag_lib.h"

#include "samples/shared/wds_diag_lib.h"

#include "my_driver_lib.h"

/*************************************************************
  General definitions
 *************************************************************/
 /* Error messages display */
#define MY_DRIVER_ERR printf

/*************************************************************
  Global variables
 *************************************************************/
 /* User's input command */
static CHAR gsInput[256];

/* --------------------------------------------------
    PCI configuration registers information
   -------------------------------------------------- */
   /* Configuration registers information array */
static const WDC_REG gMY_DRIVER_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCI_VID, WDC_SIZE_16, WDC_READ_WRITE, "VID",
        "Vendor ID" },
    { WDC_AD_CFG_SPACE, PCI_DID, WDC_SIZE_16, WDC_READ_WRITE, "DID",
        "Device ID" },
    { WDC_AD_CFG_SPACE, PCI_CR, WDC_SIZE_16, WDC_READ_WRITE, "CMD", "Command" },
    { WDC_AD_CFG_SPACE, PCI_SR, WDC_SIZE_16, WDC_READ_WRITE, "STS", "Status" },
    { WDC_AD_CFG_SPACE, PCI_REV, WDC_SIZE_32, WDC_READ_WRITE, "RID_CLCD",
        "Revision ID &\nClass Code" },
    { WDC_AD_CFG_SPACE, PCI_CCSC, WDC_SIZE_8, WDC_READ_WRITE, "SCC",
        "Sub Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CCBC, WDC_SIZE_8, WDC_READ_WRITE, "BCC",
        "Base Class Code" },
    { WDC_AD_CFG_SPACE, PCI_CLSR, WDC_SIZE_8, WDC_READ_WRITE, "CALN",
        "Cache Line Size" },
    { WDC_AD_CFG_SPACE, PCI_LTR, WDC_SIZE_8, WDC_READ_WRITE, "LAT",
        "Latency Timer" },
    { WDC_AD_CFG_SPACE, PCI_HDR, WDC_SIZE_8, WDC_READ_WRITE, "HDR",
        "Header Type" },
    { WDC_AD_CFG_SPACE, PCI_BISTR, WDC_SIZE_8, WDC_READ_WRITE, "BIST",
        "Built-in Self Test" },
    { WDC_AD_CFG_SPACE, PCI_BAR0, WDC_SIZE_32, WDC_READ_WRITE, "BADDR0",
        "Base Address 0" },
    { WDC_AD_CFG_SPACE, PCI_BAR1, WDC_SIZE_32, WDC_READ_WRITE, "BADDR1",
        "Base Address 1" },
    { WDC_AD_CFG_SPACE, PCI_BAR2, WDC_SIZE_32, WDC_READ_WRITE, "BADDR2",
        "Base Address 2" },
    { WDC_AD_CFG_SPACE, PCI_BAR3, WDC_SIZE_32, WDC_READ_WRITE, "BADDR3",
        "Base Address 3" },
    { WDC_AD_CFG_SPACE, PCI_BAR4, WDC_SIZE_32, WDC_READ_WRITE, "BADDR4",
        "Base Address 4" },
    { WDC_AD_CFG_SPACE, PCI_BAR5, WDC_SIZE_32, WDC_READ_WRITE, "BADDR5",
        "Base Address 5" },
    { WDC_AD_CFG_SPACE, PCI_CIS, WDC_SIZE_32, WDC_READ_WRITE, "CIS",
        "CardBus CIS\npointer" },
    { WDC_AD_CFG_SPACE, PCI_SVID, WDC_SIZE_16, WDC_READ_WRITE, "SVID",
        "Sub-system\nVendor ID" },
    { WDC_AD_CFG_SPACE, PCI_SDID, WDC_SIZE_16, WDC_READ_WRITE, "SDID",
        "Sub-system\nDevice ID" },
    { WDC_AD_CFG_SPACE, PCI_EROM, WDC_SIZE_32, WDC_READ_WRITE, "EROM",
        "Expansion ROM\nBase Address" },
    { WDC_AD_CFG_SPACE, PCI_CAP, WDC_SIZE_8, WDC_READ_WRITE, "NEW_CAP",
        "New Capabilities\nPointer" },
    { WDC_AD_CFG_SPACE, PCI_ILR, WDC_SIZE_32, WDC_READ_WRITE, "INTLN",
        "Interrupt Line" },
    { WDC_AD_CFG_SPACE, PCI_IPR, WDC_SIZE_32, WDC_READ_WRITE, "INTPIN",
        "Interrupt Pin" },
    { WDC_AD_CFG_SPACE, PCI_MGR, WDC_SIZE_32, WDC_READ_WRITE, "MINGNT",
        "Minimum Required\nBurst Period" },
    { WDC_AD_CFG_SPACE, PCI_MLR, WDC_SIZE_32, WDC_READ_WRITE, "MAXLAT",
        "Maximum Latency" },
};

static const WDC_REG gMY_DRIVER_ext_CfgRegs[] = {
    { WDC_AD_CFG_SPACE, PCIE_CAP_ID, WDC_SIZE_8, WDC_READ_WRITE, "PCIE_CAP_ID",
        "PCI Express\nCapability ID" },
    { WDC_AD_CFG_SPACE, NEXT_CAP_PTR, WDC_SIZE_8, WDC_READ_WRITE, "NEXT_CAP_PTR",
        "Next Capabiliy Pointer" },
    { WDC_AD_CFG_SPACE, CAP_REG, WDC_SIZE_16, WDC_READ_WRITE, "CAP_REG",
        "Capabilities Register" },
    { WDC_AD_CFG_SPACE, DEV_CAPS, WDC_SIZE_32, WDC_READ_WRITE, "DEV_CAPS",
        "Device Capabilities" },
    { WDC_AD_CFG_SPACE, DEV_CTL, WDC_SIZE_16, WDC_READ_WRITE, "DEV_CTL",
        "Device Control" },
    { WDC_AD_CFG_SPACE, DEV_STS, WDC_SIZE_16, WDC_READ_WRITE, "DEV_STS",
        "Device Status" },
    { WDC_AD_CFG_SPACE, LNK_CAPS, WDC_SIZE_32, WDC_READ_WRITE, "LNK_CAPS",
        "Link Capabilities" },
    { WDC_AD_CFG_SPACE, LNK_CTL, WDC_SIZE_16, WDC_READ_WRITE, "LNK_CTL",
        "Link Control" },
    { WDC_AD_CFG_SPACE, LNK_STS, WDC_SIZE_16, WDC_READ_WRITE, "LNK_STS",
        "Link Status" },
    { WDC_AD_CFG_SPACE, SLOT_CAPS, WDC_SIZE_32, WDC_READ_WRITE, "SLOT_CAPS",
        "Slot Capabilities" },
    { WDC_AD_CFG_SPACE, SLOT_CTL, WDC_SIZE_16, WDC_READ_WRITE, "SLOT_CTL",
        "Slot Control" },
    { WDC_AD_CFG_SPACE, SLOT_STS, WDC_SIZE_16, WDC_READ_WRITE, "SLOT_STS",
        "Slot Status" },
    { WDC_AD_CFG_SPACE, ROOT_CAPS, WDC_SIZE_16, WDC_READ_WRITE, "ROOT_CAPS",
        "Root Capabilities" },
    { WDC_AD_CFG_SPACE, ROOT_CTL, WDC_SIZE_16, WDC_READ_WRITE, "ROOT_CTL",
        "Root Control" },
    { WDC_AD_CFG_SPACE, ROOT_STS, WDC_SIZE_32, WDC_READ_WRITE, "ROOT_STS",
        "Root Status" },
    { WDC_AD_CFG_SPACE, DEV_CAPS2, WDC_SIZE_32, WDC_READ_WRITE, "DEV_CAPS2",
        "Device Capabilities 2" },
    { WDC_AD_CFG_SPACE, DEV_CTL2, WDC_SIZE_16, WDC_READ_WRITE, "DEV_CTL2",
        "Device Control 2" },
    { WDC_AD_CFG_SPACE, DEV_STS2, WDC_SIZE_16, WDC_READ_WRITE, "DEV_STS2",
        "Device Status 2" },
    { WDC_AD_CFG_SPACE, LNK_CAPS2, WDC_SIZE_32, WDC_READ_WRITE, "LNK_CAPS2",
        "Link Capabilities 2" },
    { WDC_AD_CFG_SPACE, LNK_CTL2, WDC_SIZE_16, WDC_READ_WRITE, "LNK_CTL2",
        "Link Control 2" },
    { WDC_AD_CFG_SPACE, LNK_STS2, WDC_SIZE_16, WDC_READ_WRITE, "LNK_STS2",
        "Link Status 2" },
    { WDC_AD_CFG_SPACE, SLOT_CAPS2, WDC_SIZE_32, WDC_READ_WRITE, "SLOT_CAPS2",
        "Slot Capabilities 2" },
    { WDC_AD_CFG_SPACE, SLOT_CTL2, WDC_SIZE_16, WDC_READ_WRITE, "SLOT_CTL2",
        "Slot Control 2" },
    { WDC_AD_CFG_SPACE, SLOT_STS2, WDC_SIZE_16, WDC_READ_WRITE, "SLOT_STS2",
        "Slot Status 2" },
};

#define MY_DRIVER_CFG_EXT_REGS_NUM sizeof(gMY_DRIVER_ext_CfgRegs) / sizeof(WDC_REG)
#define MY_DRIVER_CFG_REGS_NUM sizeof(gMY_DRIVER_CfgRegs) / sizeof(WDC_REG)

/* TODO: For read-only or write-only registers, change the direction field of
         the relevant registers in gMY_DRIVER_CfgRegs to WDC_READ or WDC_WRITE. */
         /* NOTE: You can define additional configuration registers in gMY_DRIVER_CfgRegs. */
const WDC_REG* gpMY_DRIVER_CfgRegs = gMY_DRIVER_CfgRegs;


// -----------------------------------------------
//    MY_DRIVER run-time registers information
// ----------------------------------------------- 
// Run-time registers information array
// const WDC_REG gMY_DRIVER_Regs[];
const WDC_REG* gpMY_DRIVER_Regs = NULL;

/* TODO: You can remove the comment from the gMY_DRIVER_Regs array declaration and
         fill the array with run-time registers information for your device,
         in which case be sure to set gpMY_DRIVER_Regs to point to gMY_DRIVER_Regs. */
#define MY_DRIVER_REGS_NUM 0


         /*************************************************************
           Static functions prototypes
          *************************************************************/
          /* -----------------------------------------------
              Main diagnostics menu
             ----------------------------------------------- */
             /* Main menu */
static void MenuMain(WDC_DEVICE_HANDLE* phDev);

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId);
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT* pSlot);
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT* pSlot);
static void DeviceClose(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev);
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace);

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev);
/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev);

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev);
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, MY_DRIVER_INT_RESULT* pIntResult);

/* -----------------------------------------------
    DMA memory handling
   ----------------------------------------------- */
   /* Allocate/free DMA memory menu */
static void MenuDma(WDC_DEVICE_HANDLE hDev);
/*    DMA trans     */
static void MenuDMAtrans(WDC_DEVICE_HANDLE hDev);
/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
static void MenuEvents(WDC_DEVICE_HANDLE hDev);
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction);

/*************************************************************
  Functions implementation
 *************************************************************/
int main(void)
{
    WDC_DEVICE_HANDLE hDev = NULL;
    DWORD dwStatus;

    printf("\n");
    printf("MY_DRIVER diagnostic utility.\n");
    printf("Application accesses hardware using " WD_PROD_NAME "\n");
    printf("and a Kernel PlugIn driver (%s).\n", KP_MY_DRIVER_DRIVER_NAME);

    /* Initialize the MY_DRIVER library */
    dwStatus = MY_DRIVER_LibInit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        MY_DRIVER_ERR("my_driver_diag: Failed to initialize the MY_DRIVER library: %s",
            MY_DRIVER_GetLastErr());
        return dwStatus;
    }

    PrintDbgMessage(D_ERROR, S_PCI, "WinDriver user mode version %s\n",
        WD_VERSION_STR);

    /* Find and open a PCI device (by default ID) */
    if (MY_DRIVER_DEFAULT_VENDOR_ID)
        hDev = DeviceFindAndOpen(MY_DRIVER_DEFAULT_VENDOR_ID, MY_DRIVER_DEFAULT_DEVICE_ID);

    /* Display main diagnostics menu for communicating with the device */
    MenuMain(&hDev);

    /* Perform necessary cleanup before exiting the program: */
    /* Close the device handle */
    if (hDev)
        DeviceClose(hDev);

    if (WDS_IsIpcRegistered())
        WDS_IpcUnRegister();

    /* Uninitialize libraries */
    dwStatus = MY_DRIVER_LibUninit();
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        MY_DRIVER_ERR("my_driver_diag: Failed to uninitialize the MY_DRIVER library: %s",
            MY_DRIVER_GetLastErr());
    }

    return dwStatus;
}

/* -----------------------------------------------
    Main diagnostics menu
   ----------------------------------------------- */
   /* Main menu options */
enum {
    MENU_MAIN_SCAN_BUS = 1,
    MENU_MAIN_FIND_AND_OPEN,
    MENU_MAIN_SHARED_BUFFER,
    MENU_MAIN_IPC,
    MENU_MAIN_RW_CFG_SPACE,
    MENU_MAIN_EVENTS,
    MENU_MAIN_RW_ADDR,
    MENU_MAIN_ENABLE_DISABLE_INT,
    MENU_MAIN_ALLOC_FREE_DMA,
    MENU_MAIN_DMA_TRANS,
    MENU_MAIN_RW_REGS,
    MENU_MAIN_EXIT = DIAG_EXIT_MENU,
};

/* Main diagnostics menu */
static void MenuMain(WDC_DEVICE_HANDLE* phDev)
{
    DWORD option;

    do
    {
        printf("\n");
        printf("MY_DRIVER main menu\n");
        printf("-------------\n");
        printf("%d. Scan PCI bus\n", MENU_MAIN_SCAN_BUS);
        printf("%d. Find and open a PCI device\n", MENU_MAIN_FIND_AND_OPEN);
        printf("%d. Allocate/free Shared Buffer\n", MENU_MAIN_SHARED_BUFFER);
        printf("%d. Manage IPC\n", MENU_MAIN_IPC);
        if (*phDev)
        {
            printf("%d. Read/write the PCI configuration space\n",
                MENU_MAIN_RW_CFG_SPACE);
            printf("%d. Register/unregister plug-and-play and power management "
                "events\n", MENU_MAIN_EVENTS);
            printf("%d. Read/write memory and I/O addresses on the device\n",
                MENU_MAIN_RW_ADDR);
            printf("%d. Enable/disable the device's interrupts\n",
                MENU_MAIN_ENABLE_DISABLE_INT);
            printf("%d. Allocate/free memory for DMA\n",
                MENU_MAIN_ALLOC_FREE_DMA);
            printf("%d. DMA_trans\n",
                MENU_MAIN_DMA_TRANS);
            if (MY_DRIVER_REGS_NUM)
            {
                printf("%d. Read/write the run-time registers\n",
                    MENU_MAIN_RW_REGS);
            }

        }
        printf("%d. Exit\n", MENU_MAIN_EXIT);

#ifndef MY_DRIVER_REGS_NUM
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_ALLOC_FREE_DMA : MENU_MAIN_IPC))
        {
            continue;
        }
#else /* ifdef MY_DRIVER_REGS_NUM */
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            *phDev ? MENU_MAIN_RW_REGS : MENU_MAIN_IPC))
        {
            continue;
        }
#endif /* ifdef MY_DRIVER_REGS_NUM */

        switch (option)
        {
        case MENU_MAIN_EXIT: /* Exit menu */
            break;
        case MENU_MAIN_SCAN_BUS: /* Scan bus */
            WDC_DIAG_PciDevicesInfoPrintAll(FALSE);
            break;
        case MENU_MAIN_FIND_AND_OPEN: /* Find and open a PCI device */
            if (*phDev)
                DeviceClose(*phDev);
            *phDev = DeviceFindAndOpen(0, 0);
            break;

        case MENU_MAIN_SHARED_BUFFER: /* Handle Shared Buffer Operations */
            MenuSharedBuffer();
            break;

        case MENU_MAIN_IPC: /* Register/unregister Inter-Process
                             * Communication */
            MenuIpc();
            break;
        case MENU_MAIN_RW_CFG_SPACE: /* Read/write the device's configuration
                                        space */
            MenuReadWriteCfgSpace(*phDev);
            break;
        case MENU_MAIN_EVENTS: /* Register/unregister plug-and-play and power
                                  management events */
            MenuEvents(*phDev);
            break;
        case MENU_MAIN_RW_ADDR: /* Read/write memory and I/O addresses */
            MenuReadWriteAddr(*phDev);
            break;
        case MENU_MAIN_ALLOC_FREE_DMA: /* Allocate/free DMA memory */
            MenuDma(*phDev);
            break;
        case MENU_MAIN_DMA_TRANS:  /*DMA trans*/
            MenuDMAtrans(*phDev);
            break;
        case MENU_MAIN_RW_REGS: /* Read/write the run-time registers */
            if (MY_DRIVER_REGS_NUM != 0)
                MenuReadWriteRegs(*phDev);
            else
                printf("Invalid selection\n");
            break;

        case MENU_MAIN_ENABLE_DISABLE_INT: /* Enable/disable interrupts */
            MenuInterrupts(*phDev);
            break;
        }
    } while (MENU_MAIN_EXIT != option);
}

/* -----------------------------------------------
    Device find, open and close
   ----------------------------------------------- */
   /* Find and open a PCI device */
static WDC_DEVICE_HANDLE DeviceFindAndOpen(DWORD dwVendorId, DWORD dwDeviceId)
{
    WD_PCI_SLOT slot;

    /* Find device */
    if (!DeviceFind(dwVendorId, dwDeviceId, &slot))
        return NULL;

    /* Open a device handle */
    return DeviceOpen(&slot);
}

/* Find a PCI device */
static BOOL DeviceFind(DWORD dwVendorId, DWORD dwDeviceId, WD_PCI_SLOT* pSlot)
{
    DWORD dwStatus;
    DWORD i, dwNumDevices;
    WDC_PCI_SCAN_RESULT scanResult;

    if (!dwVendorId)
    {
        /* Get vendor ID */
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwVendorId,
            "Enter vendor ID", TRUE, 0, 0))
        {
            return FALSE;
        }

        /* Get device ID */
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwDeviceId,
            "Enter device ID", TRUE, 0, 0))
        {
            return FALSE;
        }
    }

    /* Scan PCI devices */
    BZERO(scanResult);
    dwStatus = WDC_PciScanDevices(dwVendorId, dwDeviceId, &scanResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        MY_DRIVER_ERR("DeviceFind: Failed scanning the PCI bus.\n"
            "Error [0x%lx - %s]\n", dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }

    dwNumDevices = scanResult.dwNumDevices;
    if (!dwNumDevices)
    {
        printf("No matching PCI device was found for search criteria "
            "(Vendor ID 0x%lX, Device ID 0x%lX)\n", dwVendorId, dwDeviceId);

        return FALSE;
    }

    /* Display matching devices information */
    printf("\nFound %ld matching device%s "
        "[ Vendor ID 0x%lX%s, Device ID 0x%lX%s ]:\n",
        dwNumDevices, dwNumDevices > 1 ? "s" : "",
        dwVendorId, dwVendorId ? "" : " (ALL)",
        dwDeviceId, dwDeviceId ? "" : " (ALL)");

    for (i = 0; i < dwNumDevices; i++)
    {
        printf("\n");
        printf("%2ld. Vendor ID: 0x%lX, Device ID: 0x%lX\n", i + 1,
            scanResult.deviceId[i].dwVendorId,
            scanResult.deviceId[i].dwDeviceId);

        WDC_DIAG_PciDeviceInfoPrint(&scanResult.deviceSlot[i], FALSE);
    }
    printf("\n");

    /* Select device */
    if (dwNumDevices > 1)
    {
        sprintf(gsInput, "Select a device (1 - %ld): ", dwNumDevices);
        i = 0;
        if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&i, gsInput, FALSE, 1,
            dwNumDevices))
        {
            return FALSE;
        }
    }

    *pSlot = scanResult.deviceSlot[i - 1];

    return TRUE;
}

static DWORD CheckKPDriverVer(WDC_DEVICE_HANDLE hDev)
{
    KP_MY_DRIVER_VERSION kpVer;
    DWORD dwStatus;
    DWORD dwKPResult = 0;

    /* Get Kernel PlugIn Driver version */
    BZERO(kpVer);
    dwStatus = WDC_CallKerPlug(hDev, KP_MY_DRIVER_MSG_VERSION, &kpVer, &dwKPResult);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        MY_DRIVER_ERR("Failed sending a \'Get Version\' message [0x%x] to the "
            "Kernel-PlugIn driver [%s]. Error [0x%lx - %s]\n",
            KP_MY_DRIVER_MSG_VERSION, KP_MY_DRIVER_DRIVER_NAME, dwStatus,
            Stat2Str(dwStatus));
    }
    else if (KP_MY_DRIVER_STATUS_OK != dwKPResult)
    {
        MY_DRIVER_ERR("Kernel-PlugIn \'Get Version\' message [0x%x] failed. "
            "Kernel PlugIn status [0x%lx]\n", KP_MY_DRIVER_MSG_VERSION, dwKPResult);
        dwStatus = WD_INCORRECT_VERSION;
    }
    else
    {
        printf("Using [%s] Kernel-Plugin driver version [%ld.%02ld - %s]\n",
            KP_MY_DRIVER_DRIVER_NAME, kpVer.dwVer / 100, kpVer.dwVer % 100,
            kpVer.cVer);
    }

    return dwStatus;
}

/* Open a handle to a PCI device */
static WDC_DEVICE_HANDLE DeviceOpen(const WD_PCI_SLOT* pSlot)
{
    WDC_DEVICE_HANDLE hDev;
    DWORD dwStatus;
    WD_PCI_CARD_INFO deviceInfo;

    /* Retrieve the device's resources information */
    BZERO(deviceInfo);
    deviceInfo.pciSlot = *pSlot;
    dwStatus = WDC_PciGetDeviceInfo(&deviceInfo);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        MY_DRIVER_ERR("DeviceOpen: Failed retrieving the device's resources "
            "information. Error [0x%lx - %s]\n", dwStatus, Stat2Str(dwStatus));
        return NULL;
    }

    /* NOTE: If necessary, you can modify the device's resources information
       here - mainly the information stored in the deviceInfo.Card.Items array,
       and the number of array items stored in deviceInfo.Card.dwItems.
       For example:
       - Edit the deviceInfo.Card.Items array and/or deviceInfo.Card.dwItems,
         to register only some of the resources or to register only a portion
         of a specific address space.
       - Set the fNotSharable field of one or more items in the
         deviceInfo.Card.Items array to 1, to block sharing of the related
         resources and ensure that they are locked for exclusive use.
    */

    /* Open a handle to the device */
    hDev = MY_DRIVER_DeviceOpen(&deviceInfo);
    if (!hDev)
    {
        MY_DRIVER_ERR("DeviceOpen: Failed opening a handle to the device: %s",
            MY_DRIVER_GetLastErr());
        return NULL;
    }

    /* Get Kernel PlugIn driver version */
    if (WDC_IS_KP(hDev))
        CheckKPDriverVer(hDev);

    return hDev;
}

/* Close handle to a PCI device */
static void DeviceClose(WDC_DEVICE_HANDLE hDev)
{
    /* Validate the WDC device handle */
    if (!hDev)
        return;

    /* Close the WDC device handle */
    if (!MY_DRIVER_DeviceClose(hDev))
        MY_DRIVER_ERR("DeviceClose: Failed closing PCI device: %s", MY_DRIVER_GetLastErr());
}

/* -----------------------------------------------
    Read/write memory and I/O addresses
   ----------------------------------------------- */
   /* Read/write address menu options */
enum {
    MENU_RW_ADDR_SET_ADDR_SPACE = 1,
    MENU_RW_ADDR_SET_MODE,
    MENU_RW_ADDR_SET_TRANS_TYPE,
    MENU_RW_ADDR_READ,
    MENU_RW_ADDR_WRITE,
    MENU_RW_ADDR_EXIT = DIAG_EXIT_MENU,
};

#define ACTIVE_ADDR_SPACE_NEEDS_INIT 0xFF

/* Read/write memory or I/O space address menu */
static void MenuReadWriteAddr(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    static DWORD dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
    static WDC_ADDR_MODE mode = WDC_MODE_32;
    static BOOL fBlock = FALSE;

    /* Initialize active address space */
    if (ACTIVE_ADDR_SPACE_NEEDS_INIT == dwAddrSpace)
    {
        DWORD dwNumAddrSpaces = MY_DRIVER_GetNumAddrSpaces(hDev);
        /* Find the first active address space */
        for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
        {
            if (WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
                break;
        }

        /* Sanity check */
        if (dwAddrSpace == dwNumAddrSpaces)
        {
            MY_DRIVER_ERR("MenuReadWriteAddr: Error - No active address spaces "
                "found\n");
            dwAddrSpace = ACTIVE_ADDR_SPACE_NEEDS_INIT;
            return;
        }
    }

    do
    {
        printf("\n");
        printf("Read/write the device's memory and I/O ranges\n");
        printf("----------------------------------------------\n");
        printf("%d. Change active address space for read/write ",
            MENU_RW_ADDR_SET_ADDR_SPACE);
        printf("(currently: BAR %ld)\n", dwAddrSpace);
        printf("%d. Change active read/write mode (currently: %s)\n",
            MENU_RW_ADDR_SET_MODE,
            (WDC_MODE_8 == mode) ? "8 bit" : (WDC_MODE_16 == mode) ? "16 bit" :
            (WDC_MODE_32 == mode) ? "32 bit" : "64 bit");
        printf("%d. Toggle active transfer type (currently: %s)\n",
            MENU_RW_ADDR_SET_TRANS_TYPE,
            fBlock ? "block transfers" : "non-block transfers");
        printf("%d. Read from active address space\n", MENU_RW_ADDR_READ);
        printf("%d. Write to active address space\n", MENU_RW_ADDR_WRITE);
        printf("%d. Exit menu\n", MENU_RW_ADDR_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option, MENU_RW_ADDR_WRITE))
            continue;

        switch (option)
        {
        case MENU_RW_ADDR_EXIT: /* Exit menu */
            break;
        case MENU_RW_ADDR_SET_ADDR_SPACE: /* Set active address space for
                                             read/write address requests */
            SetAddrSpace(hDev, &dwAddrSpace);
            break;
        case MENU_RW_ADDR_SET_MODE: /* Set active mode for read/write address
                                       requests */
            WDC_DIAG_SetMode(&mode);
            break;
        case MENU_RW_ADDR_SET_TRANS_TYPE: /* Toggle active transfer type */
            fBlock = !fBlock;
            break;
        case MENU_RW_ADDR_READ:  /* Read from a memory or I/O address */
        case MENU_RW_ADDR_WRITE: /* Write to a memory or I/O address */
        {
            WDC_DIRECTION direction =
                (MENU_RW_ADDR_READ == option ? WDC_READ : WDC_WRITE);

            if (fBlock)
                WDC_DIAG_ReadWriteBlock(hDev, direction, dwAddrSpace);
            else
                WDC_DIAG_ReadWriteAddr(hDev, direction, dwAddrSpace, mode);

            break;
        }
        }
    } while (MENU_RW_ADDR_EXIT != option);
}

/* Set address space */
static void SetAddrSpace(WDC_DEVICE_HANDLE hDev, PDWORD pdwAddrSpace)
{
    DWORD dwAddrSpace;
    DWORD dwNumAddrSpaces = MY_DRIVER_GetNumAddrSpaces(hDev);
    MY_DRIVER_ADDR_SPACE_INFO addrSpaceInfo;

    printf("\n");
    printf("Select an active address space:\n");
    printf("-------------------------------\n");

    for (dwAddrSpace = 0; dwAddrSpace < dwNumAddrSpaces; dwAddrSpace++)
    {
        BZERO(addrSpaceInfo);
        addrSpaceInfo.dwAddrSpace = dwAddrSpace;
        if (!MY_DRIVER_GetAddrSpaceInfo(hDev, &addrSpaceInfo))
        {
            MY_DRIVER_ERR("SetAddrSpace: Error - Failed to get address space "
                "information. Last error [%s]", MY_DRIVER_GetLastErr());
            return;
        }

        printf("%ld. %-*s %-*s %s\n",
            dwAddrSpace + 1,
            MAX_NAME_DISPLAY, addrSpaceInfo.sName,
            MAX_TYPE - 1, addrSpaceInfo.sType,
            addrSpaceInfo.sDesc);
    }
    printf("\n");

    if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&dwAddrSpace,
        "Enter option", FALSE, 1, dwNumAddrSpaces))
    {
        return;
    }

    dwAddrSpace--;
    if (!WDC_AddrSpaceIsActive(hDev, dwAddrSpace))
    {
        printf("You have selected an inactive address space\n");
        return;
    }

    *pdwAddrSpace = dwAddrSpace;
}

/* -----------------------------------------------
    Read/write the configuration space
   ----------------------------------------------- */
   /* Read/write the configuration space menu options */
enum {
    MENU_RW_CFG_SPACE_READ_OFFSET = 1,
    MENU_RW_CFG_SPACE_WRITE_OFFSET,
    MENU_RW_CFG_SPACE_READ_ALL_REGS,
    MENU_RW_CFG_SPACE_READ_REG,
    MENU_RW_CFG_SPACE_WRITE_REG,
    MENU_RW_CFG_SPACE_EXT_READ_REG,
    MENU_RW_CFG_SPACE_EXT_WRITE_REG,
    MENU_RW_CFG_SPACE_SCAN_CAP,
    MENU_RW_CFG_SPACE_EXIT = DIAG_EXIT_MENU,
};

/* Read/write configuration space menu */
static void MenuReadWriteCfgSpace(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fExpress = WDC_PciGetExpressGen(hDev) != 0;
    do {
        /* Display predefined registers information */
        printf("\n");
        printf("Configuration registers:\n");
        printf("------------------------\n");
        WDC_DIAG_RegsInfoPrint(hDev, gMY_DRIVER_CfgRegs, MY_DRIVER_CFG_REGS_NUM,
            WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE, FALSE);
        if (fExpress)
        {
            WDC_DIAG_RegsInfoPrint(hDev, gMY_DRIVER_ext_CfgRegs, MY_DRIVER_CFG_EXT_REGS_NUM,
                WDC_DIAG_REG_PRINT_ALL & ~WDC_DIAG_REG_PRINT_ADDR_SPACE, TRUE);
        }
        printf("\n");
        printf("Read/write the device's configuration space\n");
        printf("--------------------------------------------\n");
        printf("%d. Read from an offset\n", MENU_RW_CFG_SPACE_READ_OFFSET);
        printf("%d. Write to an offset\n", MENU_RW_CFG_SPACE_WRITE_OFFSET);
        printf("%d. Read all configuration registers defined for the device "
            "(see list above)\n", MENU_RW_CFG_SPACE_READ_ALL_REGS);
        printf("%d. Read from a named register\n", MENU_RW_CFG_SPACE_READ_REG);
        printf("%d. Write to a named register\n", MENU_RW_CFG_SPACE_WRITE_REG);
        if (fExpress)
        {
            printf("%d. Read from a named PCI Express register\n",
                MENU_RW_CFG_SPACE_EXT_READ_REG);
            printf("%d. Write to a named PCI Express register\n",
                MENU_RW_CFG_SPACE_EXT_WRITE_REG);
        }
        printf("%d. Scan PCI/PCIe capabilities\n", MENU_RW_CFG_SPACE_SCAN_CAP);
        printf("%d. Exit menu\n", MENU_RW_CFG_SPACE_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_CFG_SPACE_SCAN_CAP))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_CFG_SPACE_EXIT: /* Exit menu */
            break;
        case MENU_RW_CFG_SPACE_READ_OFFSET: /* Read from a configuration space
                                               offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_READ, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_OFFSET: /* Write to a configuration space
                                                offset */
            WDC_DIAG_ReadWriteBlock(hDev, WDC_WRITE, WDC_AD_CFG_SPACE);
            break;
        case MENU_RW_CFG_SPACE_READ_ALL_REGS:
            WDC_DIAG_ReadRegsAll(hDev, gMY_DRIVER_CfgRegs, MY_DRIVER_CFG_REGS_NUM,
                TRUE, FALSE);
            if (fExpress)
            {
                WDC_DIAG_ReadRegsAll(hDev, gMY_DRIVER_ext_CfgRegs,
                    MY_DRIVER_CFG_EXT_REGS_NUM, TRUE, TRUE);
            }
            break;
        case MENU_RW_CFG_SPACE_READ_REG:  /* Read from a configuration
                                             register */
            WDC_DIAG_ReadWriteReg(hDev, gMY_DRIVER_CfgRegs, MY_DRIVER_CFG_REGS_NUM,
                WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_WRITE_REG: /* Write to a configuration
                                             register */
            WDC_DIAG_ReadWriteReg(hDev, gMY_DRIVER_CfgRegs, MY_DRIVER_CFG_REGS_NUM,
                WDC_WRITE, TRUE);
            break;
        case MENU_RW_CFG_SPACE_EXT_WRITE_REG: /* Write to a configuration
                                             PCI Express register */
            WDC_DIAG_ReadWriteReg(hDev, gMY_DRIVER_ext_CfgRegs, MY_DRIVER_CFG_EXT_REGS_NUM,
                WDC_WRITE, TRUE);
            break;
        case MENU_RW_CFG_SPACE_EXT_READ_REG:  /* Read from a configuration
                                             PCI Express register */
            WDC_DIAG_ReadWriteReg(hDev, gMY_DRIVER_ext_CfgRegs, MY_DRIVER_CFG_EXT_REGS_NUM,
                WDC_READ, TRUE);
            break;
        case MENU_RW_CFG_SPACE_SCAN_CAP: /* Scan PCI/PCIe capabilities */
            WDC_DIAG_ScanPCICapabilities(hDev);
            break;
        }
    } while (MENU_RW_CFG_SPACE_EXIT != option);
}
/*DMA Trans MENU*/
enum {
    MENU_DMA_1 = 1,
    MENU_DMA_2,
    MENU_DMA_3,
    MENU_DMA_4,
    MENU_DMA_5,
    MENU_DMA_6,
    MENU_DMA_7,
    MENU_DMA_8,
    MENU_DMA_9,
    MENU_DMA_10,
    MENU_DMA_11,
    MENU_DMA_TEXIT = DIAG_EXIT_MENU,
};
PVOID pBuf;
PVOID Desc[30];
DWORD DescPhysicalAddr[30] = { 0 };
/*functions  declare*/
BOOL DMARoutine(WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize,
    BOOL fPolling, BOOL fToDev, DWORD* DescNum);
BOOL DMAOpen(WDC_DEVICE_HANDLE hDev, PVOID pBuf,
    DWORD dwDMABufSize, BOOL fToDev, WD_DMA** ppDma, DWORD* descnum);/* UINT32 u32LocalAddr,未使用*/
BOOL MyDMAStart(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, DWORD* descNum);
BOOL MyDMAWaitForCompletion(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, int fPooling);
BOOL MyDMAPageProgram(WDC_DEVICE_HANDLE hDev, int dwPageNumber, char* PASS, KPTR PhysicalAddr, DWORD dwBytes, DWORD dwOptions);
void DMAClose(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, BOOL fPolling);
void DMA_RegisterRead(WDC_DEVICE_HANDLE hDev);
void DMA_BufferRead();

/*MAIN DMA Trans funcition*/

/*varibles*/
int fToDev = 0;/*数据传输的方向 fTodev=1 means direction，zero means from device to PC memory */
int dwDMABufSize = 20000;/*申请内存的大小*/
int fPolling = 1;/*中断是否允许的标志*/  /*fPooling 是轮询标志位？这个需要解决一下  */
    /*如果fPolling 是0，是允许中断，如果fPolling是1，是禁止中断*/

static void MenuDMAtrans(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    /*varibles*/
    DWORD* DescNum = NULL;
    DWORD DESC = 0;
    DescNum = &DESC;
    WORD Flag = 0;
    do {
        printf("\n");
        printf("DMA \n");
        printf("---------\n");
        printf("%d. DMA Reset\n", MENU_DMA_1);
        printf("%d. Descriptor Create\n", MENU_DMA_2);
        printf("%d. DMA Start\n", MENU_DMA_3);
        printf("%d. free buff\n", MENU_DMA_4);
        printf("%d. display flags\n", MENU_DMA_5);
        printf("%d. App0 Enable to generate\n", MENU_DMA_6);
        printf("%d. App0 Unable to generate\n", MENU_DMA_7);
        printf("%d. App1 Enable to generate\n", MENU_DMA_8);
        printf("%d. App1 Unable to generate\n", MENU_DMA_9);
        printf("%d. Read Data Buffer\n", MENU_DMA_10);
        printf("%d. EXIT\n", MENU_DMA_TEXIT);
        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option, MENU_DMA_11));
        switch (option)
        {
        case MENU_DMA_TEXIT:
            break;
        case MENU_DMA_1:
            if (WDC_WriteAddr16(hDev, 0, 0x2004, 0x8000) != 0)  printf("Fail to reset\n");
            WDC_WriteAddr16(hDev, 0, 0x4000, 0x31);/*中断位*/
            printf("Sucessful to Reset DMA\n");
            break;
        case MENU_DMA_2:
            DMARoutine(hDev, dwDMABufSize, fPolling, fToDev, DescNum);/*参数u32LocalAddr未使用*/
            break;
        case MENU_DMA_3:
            WDC_WriteAddr16(hDev, 0, 0x2004, 0x0101);/*使能DMA引擎，并允许中断*/
            break;
        case MENU_DMA_4:
            printf("Don't know how to free/n");
            break;
        case MENU_DMA_5:
            DMA_RegisterRead(hDev);
            break;
        case MENU_DMA_6:
            WDC_WriteAddr32(hDev, 0, 0x9100, 1);//0的位置是第几个bar基址
            break;
        case MENU_DMA_7:
            WDC_WriteAddr32(hDev, 0, 0x9100, 0);
            break;
        case MENU_DMA_8:
            WDC_WriteAddr32(hDev, 0, 0x9200, 1);
            break;
        case MENU_DMA_9:
            WDC_WriteAddr32(hDev, 0, 0x9200, 0);
            break;
        case MENU_DMA_10:
            DMA_BufferRead();
            break;
        case MENU_DMA_11:
            printf("Don't know how to free buffer\n");
            break;
        }
    }while (MENU_DMA_TEXIT != option);
}
/*目前u32LocalAddr还未管是什么参数,可能出现在DMARoutine函数里面*/
BOOL DMARoutine(WDC_DEVICE_HANDLE hDev, DWORD dwDMABufSize,
    BOOL fPolling, BOOL fToDev, DWORD* DescNum)
{   WD_DMA* pDma = NULL;
    BOOL fRet = FALSE;
    /* Allocate a user-mode buffer for Scatter/Gather DMA */
    pBuf = malloc(dwDMABufSize);
    if (!pBuf)
        return FALSE;
    memset(pBuf, 0, dwDMABufSize);
    /* Lock the DMA buffer */
    if (!DMAOpen(hDev, pBuf, dwDMABufSize, fToDev, &pDma, DescNum))
    {
        printf("Fail to Open DMA\n");
        goto Exit;
    }
    printf("success to Open DMA\n");
    /* Enable DMA interrupts (if not polling) */
    if (!fPolling)
    {
        // if (!MyDMAInterruptEnable(hDev, MyDmaIntHandler, pDma))
        //   goto Exit; /* Failed enabling DMA interrupts */
    }

    /* Flush the CPU caches (see documentation of WDC_DMASyncCpu()) */
    WDC_DMASyncCpu(pDma);

    printf("success to flush the CPU caches\n");

    /* Start DMA - write to the device to initiate the DMA transfer */
    MyDMAStart(hDev, pDma, DescNum);

    /* Wait for the DMA transfer to complete */
    MyDMAWaitForCompletion(hDev, pDma, fPolling);
    printf("The transmit buffer is:\n");
    /* Flush the I/O caches (see documentation of WDC_DMASyncIo()) */
    WDC_DMASyncIo(pDma);
    fRet = TRUE;
    return fRet;
Exit:
    DMAClose(hDev, pDma, fPolling);
    free(pBuf);
    return FALSE;
}

/* DMAOpen: Locks a Scatter/﻿Gather DMA buffer */
/*描述符的结构体定义/*为了地址的一致性（描述符的末地址的5位必须是0）
自己的理解是，DMA读操作这样时是整数，不然DMA没办法完成整数次数的读写
现在采用申请内存移动指针的方式，强行将描述符的地址移动到末5位是0*/
//struct DMADESC Desc[50] = { 0,0,0,0,0,0,0 };/*描述符环的初始化*/
/*建立对应数量的描述符*/
/*  DWORD TEST[20] = { 0 };
    DWORD result[20] = { 0 };
    for (dwPageNumber = 0;dwPageNumber < DescNumber;dwPageNumber++)
    {
        TEST[dwPageNumber] = (DWORD)&Desc[dwPageNumber];
        result[dwPageNumber] = TEST[dwPageNumber] % 32;
        if(result[dwPageNumber] != 0) {
            printf("ReStart\n");
            goto RESTART;
        }
    }*/

BOOL DMAOpen(WDC_DEVICE_HANDLE hDev, PVOID pBuf,
    DWORD dwDMABufSize, BOOL fToDev, WD_DMA** ppDma, DWORD* descnum)/* UINT32 u32LocalAddr,未使用*/
{
    DWORD dwStatus, dwPageNumber;
    DWORD dwOptions = fToDev ? DMA_TO_DEVICE : DMA_FROM_DEVICE;

    /* Lock a Scatter/﻿Gather DMA buffer */
    dwStatus = WDC_DMASGBufLock(hDev, pBuf, dwOptions, dwDMABufSize, ppDma);
    if (WD_STATUS_SUCCESS != dwStatus)
    {
        printf("Failed locking a Scatter/﻿Gather DMA buffer. Error 0x%lx - %s\n",
            dwStatus, Stat2Str(dwStatus));
        return FALSE;
    }
    /* Program the device's DMA registers for each physical page */
    DWORD DescNumber = (*ppDma)->dwPages;/*描述符的个数*/
    *descnum = DescNumber;
    printf("建立%d个描述符\n", DescNumber);
    /*由于定义数组时必须是常量，所以多定义几个描述符，多余的先放一边不管*/
    /*想法：申请一快内存，然后找到对应低5位为0的地方，开始建立描述符*/
    DWORD DescCount = 0, offset = 0;
    char* AddrDesc = NULL;
    WD_DMA* PhyDMA = NULL;
    for (DescCount = 0; DescCount < DescNumber; DescCount++)
    {
        Desc[DescCount] = malloc(65);
        memset(Desc[DescCount], 0, 65);
        AddrDesc = Desc[DescCount];
        offset = (unsigned int)AddrDesc % 32;
        if (offset == 0) {
            Desc[DescCount] = AddrDesc;
        }
        else {
            AddrDesc = AddrDesc + 32 - offset;
            Desc[DescCount] = AddrDesc;
        }
        dwStatus = WDC_DMASGBufLock(hDev, Desc[DescCount], dwOptions, 32, &PhyDMA);
        //printf("第%d个 lock buffer user address is %x\t", DescCount+1,PhyDMA->pUserAddr);
        //printf("第%d个 lock buffer physical address is %x\n", DescCount + 1, PhyDMA->Page[0].pPhysicalAddr);
        //printf("the addrress of user Ptr is %p\n", DescCount + 1, Desc[DescCount]);
        DescPhysicalAddr[DescCount] = (DWORD)(PhyDMA->Page[0].pPhysicalAddr);/*获得描述符的物理地址*/
    }
    /*下一个描述符的地址给前一个描述符的末尾*/
    /*描述符的next指针*/
    DWORD* PASS = NULL;
    for (dwPageNumber = 0; dwPageNumber < DescNumber; dwPageNumber++)
    {
        PASS = NULL;
        if (DescNumber == 1) {/*只有一个描述符的话,直接在第一个描述符位置写0*/
            /*这里为什么不是7，而是28*/
            PASS = (DWORD*)((char*)Desc[dwPageNumber] + 28);
            *PASS = DescPhysicalAddr[0];
        }
        else if (dwPageNumber == (DescNumber - 1)) {
            PASS = (DWORD*)((char*)Desc[dwPageNumber] + 28);
            *PASS = DescPhysicalAddr[0];/*最后一个描述符*/
        }
        else {
            PASS = (DWORD*)((char*)Desc[dwPageNumber] + 28);
            *PASS = DescPhysicalAddr[dwPageNumber + 1];
        }
    }
    PASS = NULL;
    char* PASS_1 = NULL;
    for (dwPageNumber = 0; dwPageNumber < (*ppDma)->dwPages; dwPageNumber++)
    {   /*在这个函数里，把描述符建立好*/
        PASS_1 = Desc[dwPageNumber];
        MyDMAPageProgram(hDev, dwPageNumber, PASS_1, (*ppDma)->Page[dwPageNumber].pPhysicalAddr,
            (*ppDma)->Page[dwPageNumber].dwBytes, dwOptions);
        //MyDMAProgram((*ppDma)->Page, (*ppDma)->dwPages, fToDev,);/*u32LocalAddr未使用*/
    }
    PASS = NULL;
    //free(PASS);
    //for (dwPageNumber = 0; dwPageNumber < DescNumber; dwPageNumber++) {
    //  printf("第%d个描述符的构成\n此描述符的地址%p\n第一行%x\n用户状态寄存器%llx\nDMA地址%lx\n缓冲区大小%x%d\n"
    //      "描述符驱动写入的状态位%d\nbuffer的物理地址%llx\n下一个描述符的地址%p\n",
    //      dwPageNumber + 1, &Desc[dwPageNumber], Desc[dwPageNumber].C2SStatus, Desc[dwPageNumber].UserStatus, Desc[dwPageNumber].DescCardAddr,
    //      Desc[dwPageNumber].Rsvd_ByteCount, Desc[dwPageNumber].DescByteCount, Desc[dwPageNumber].C2SDescControlFlags, Desc[dwPageNumber].DescSystemAddr, Desc[dwPageNumber].DescNextDescPtr);
    //  printf("buffer的大小，高4位%x\n", Desc[dwPageNumber].Rsvd_ByteCount);
    //  printf("buffer的大小，低16位%x\n\n\n", Desc[dwPageNumber].DescByteCount);
    /*reset DMA engine*/
    //WDC_WriteAddr32(hDev, 0, 0x9108, 0);/*loop back checker app0关*/
    //WDC_WriteAddr32(hDev, 0, 0x9208, 0);/*loop back checker app1关*/
    //WDC_WriteAddr32(hDev, 0, 0x9100, 0);/*此处是app0的generator位*/
    //WDC_WriteAddr32(hDev, 0, 0x9200, 0);/*此处是app1的generator位*/
    return TRUE;
}
struct DMADESC {
    DWORD C2SStatus;/*前8位是状态标志位，中间留4位，后面20位是bytecount*/
    KPTR UserStatus;/*用户状态寄存器64位*/
    //DWORD HighUserStatus;/*用户状态寄存器高32位*/
    DWORD DescCardAddr;/*需要传输数据时，DMA方面的地址，的低32位*/
    WORD  DescByteCount;/*此描述符所包含的buffer的大小，但是是buffer的低16位*/
    char  Rsvd_ByteCount;/*高4位是reserved，低4位是DescByteCount的高4位*/
    char  C2SDescControlFlags;/*传输标志位，最低位是irqc,第二低位是irqer*/
    KPTR DescSystemAddr;/*传输数据的PC端内存的物理地址的低32位*/
                           /*传输的数据的PC端内存的物理地址的高32位*/
    struct DMADESC* DescNextDescPtr;/*高27位，代表下一个描述符的指针*/
};
DWORD* DESC_C2SSatus = NULL;
KPTR* DESC_UserStatus = NULL;
DWORD* DESC_DescCardAddr = NULL;
WORD* DESC_DescByteCount = NULL;
char* DESC_Rsvd_ByteCount = NULL;
char* DESC_C2SDescControlFlags = NULL;
KPTR* DESC_DescSystemAddr = NULL;
DWORD* DESC_DescNextDescPtr = NULL;

/*MyProgram 打印描述符*/
BOOL MyDMAPageProgram(WDC_DEVICE_HANDLE hDev, int dwPageNumber, char* PASS, KPTR PhysicalAddr, DWORD dwBytes, DWORD dwOptions)
{
    DESC_C2SSatus = (DWORD*)((char*)PASS);
    DESC_UserStatus = (KPTR*)((char*)PASS + 4);
    DESC_DescCardAddr = (DWORD*)((char*)PASS + 12);
    DESC_DescByteCount = (WORD*)((char*)PASS + 16);
    DESC_Rsvd_ByteCount = (char*)PASS + 18;
    DESC_C2SDescControlFlags = (char*)PASS + 19;
    DESC_DescSystemAddr = (KPTR*)((char*)PASS + 20);
    DESC_DescNextDescPtr = (DWORD*)((char*)PASS + 28);
    *DESC_DescSystemAddr = PhysicalAddr;/*描述符环对应的buffer地址*/
    *DESC_DescByteCount = (WORD)dwBytes;/*这里只有低16位的数量*/
    *DESC_C2SDescControlFlags = (char)3;/*这里把irqer和irqc置为1*//* = C2SDescControlFlags*/
    printf("第%d个buffer的大小为%d\n", dwPageNumber + 1, *DESC_DescByteCount);
    printf("第%d个描述符的构成\n"
        "C2S_Status %x\n"
        "用户状态寄存器 %llx\n"
        "DMA地址 %x\n"
        "缓冲区大小 %d%d\n"
        "描述符驱动写入的状态位 %d\n"
        "buffer的物理地址 %llx\n"
        "下一个描述符的物理地址 %x\n\n",
        dwPageNumber + 1,
        *DESC_C2SSatus,
        *DESC_UserStatus,
        *DESC_DescCardAddr,
        *DESC_Rsvd_ByteCount,
        *DESC_DescByteCount,
        *DESC_C2SDescControlFlags,
        *DESC_DescSystemAddr,
        *DESC_DescNextDescPtr);
    PASS = NULL;
    DESC_C2SSatus = NULL;
    DESC_UserStatus = NULL;
    DESC_DescCardAddr = NULL;
    DESC_DescByteCount = NULL;
    DESC_Rsvd_ByteCount = NULL;
    DESC_C2SDescControlFlags = NULL;
    DESC_DescSystemAddr = NULL;
    DESC_DescNextDescPtr = NULL;
    return 1;
}

/*  myDMAStart  */
BOOL MyDMAStart(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, DWORD* descNum)
{
    /*先将描述符环写入对应寄存器*/
    /*其中REG_NEXT_DESC_Ptr[31:5]写入第一个描述符的地址，给硬件的描述符,寄存器在0x8-0xB*/
    WDC_WriteAddr32(hDev, 0, 0x2008, DescPhysicalAddr[0]);
    /*其中REG_SW_DESC_Ptr[31:5]写入最后一个描述符的地址，要保证至少有一个描述符在软件手中，寄存器在0xC-0xF*/
    WDC_WriteAddr32(hDev, 0, 0x200c, DescPhysicalAddr[*descNum - 1]);
    //printf("the value of 0x8 should be %x\n", DescPhysicalAddr[0]);
    //printf("the value of 0xc should be %x\n", DescPhysicalAddr[*descNum-1]);
    return 1;
}
/*read DMA regigster */
WORD Flags = 0;
DWORD HW_Ptr = 0;
DWORD SW_Ptr = 0;
void DMA_RegisterRead(WDC_DEVICE_HANDLE hDev) {
    WORD Flags = 0;
    DWORD HW_Ptr = 0;
    DWORD SW_Ptr = 0;
    WDC_ReadAddr16(hDev, 0, 0x2004, &Flags);
    WDC_ReadAddr32(hDev, 0, 0x2008, &HW_Ptr);
    WDC_ReadAddr32(hDev, 0, 0x200c, &SW_Ptr);
    WORD Rest = Flags;
    WORD Flag[16] = { 0 };
    int i = 0;
    for (i = 0; i < 16; i++)
    {
        Flag[i] = Rest % 2;
        Rest = Rest / 2;
    }
    printf("The Interrupt Enable Flag is %d\n", Flag[0]);
    printf("The Interrupt Active Flag is %d\n", Flag[1]);
    printf("The Descriptor Complete Flag is %d\n", Flag[2]);
    printf("The Descriptor Alignment Error Flag is %d\n", Flag[3]);
    printf("The Descriptor Fetch Error Flag is %d\n", Flag[4]);
    printf("The SW_Abort_Error Flag is %d\n", Flag[5]);
    //printf("");
    //printf("");
    printf("The DMA Enable Flag is %d\n", Flag[8]);
    //printf("");
    printf("The DMA_Running Flag is %d\n", Flag[10]);
    printf("The DMA_Waiting Flag is %d\n", Flag[11]);
    //printf("");
    //printf("");
    printf("The DMA_Reset_Request Flag is %d\n", Flag[14]);
    printf("The DMA_Reset Flag is %d\n", Flag[15]);
    printf("The Flags are %x\n", Flags);
    printf("The HardWare NEXT_Ptr is %x\n", HW_Ptr);
    printf("The SoftWare Ptr is %x\n", SW_Ptr);
}

void DMA_BufferRead()
{
    int buffercount = 0;
    unsigned int* Bufferread = pBuf;
    for (buffercount = 0; buffercount < (dwDMABufSize / 4);)
    {
        if ((buffercount % 32) == 0) {
            printf("\n");
        }
        printf("%x", *(Bufferread + 3));
        printf("%x", *(Bufferread + 2));
        printf("%x", *(Bufferread + 1));
        printf("%x", *(Bufferread));
        printf("\t\t");
        Bufferread = Bufferread + 4;
        buffercount = buffercount + 4;
    }
    Bufferread = NULL;
    printf("\n");
}
/*  MyDMAWaitForCompletion  */
BOOL MyDMAWaitForCompletion(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, int fPooling)
{
    printf("You haven't finish how to Wait For Completion\n");
    return 1;
}
/* DMAClose: Unlocks a previously locked Scatter/﻿Gather DMA buffer */
void DMAClose(WDC_DEVICE_HANDLE hDev, WD_DMA* pDma, BOOL fPolling)
{
    /* Disable DMA interrupts (if not polling) */
    if (!fPolling)
        //    MyDMAInterruptDisable(hDev);

        /* Unlock and free the DMA buffer */
        WDC_DMABufUnlock(pDma);
}



/* -----------------------------------------------
    Read/write the run-time registers
   ----------------------------------------------- */
   /* Read/write the run-time registers menu options */
enum {
    MENU_RW_REGS_READ_ALL = 1,
    MENU_RW_REGS_READ_REG,
    MENU_RW_REGS_WRITE_REG,
    MENU_RW_REGS_EXIT = DIAG_EXIT_MENU,
};
/* Display read/write run-time registers menu */
static void MenuReadWriteRegs(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;

    if (MY_DRIVER_REGS_NUM == 0)
    {
        printf("There are currently no pre-defined run-time registers\n");
        return;
    }

    do {
        /* Display pre-defined registers' information */
        printf("\n");
        printf("MY_DRIVER run-time registers:\n");
        printf("--------------------------\n");
        WDC_DIAG_RegsInfoPrint(hDev, gpMY_DRIVER_Regs, MY_DRIVER_REGS_NUM, WDC_DIAG_REG_PRINT_ALL, FALSE);

        printf("\n");
        printf("Read/write the MY_DRIVER run-time registers\n");
        printf("-----------------------------------------\n");
        printf("%d. Read all run-time registers defined for the device (see list above)\n",
            MENU_RW_REGS_READ_ALL);
        printf("%d. Read from a specific register\n", MENU_RW_REGS_READ_REG);
        printf("%d. Write to a specific register\n", MENU_RW_REGS_WRITE_REG);
        printf("%d. Exit menu\n", MENU_RW_REGS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_RW_REGS_WRITE_REG))
        {
            continue;
        }

        switch (option)
        {
        case MENU_RW_REGS_EXIT: /* Exit menu */
            break;
        case MENU_RW_REGS_READ_ALL:
            WDC_DIAG_ReadRegsAll(hDev, gpMY_DRIVER_Regs, MY_DRIVER_REGS_NUM, FALSE, FALSE);
            break;
        case MENU_RW_REGS_READ_REG:  /* Read from a register */
            WDC_DIAG_ReadWriteReg(hDev, gpMY_DRIVER_Regs, MY_DRIVER_REGS_NUM, WDC_READ, FALSE);
            break;
        case MENU_RW_REGS_WRITE_REG: /* Write to a register */
            WDC_DIAG_ReadWriteReg(hDev, gpMY_DRIVER_Regs, MY_DRIVER_REGS_NUM, WDC_WRITE, FALSE);
            break;
        }
    } while (MENU_RW_REGS_EXIT != option);
}

/* -----------------------------------------------
    Interrupt handling
   ----------------------------------------------- */
   /* Interrupts menu options */
enum {
    MENU_INT_ENABLE_DISABLE = 1,
    MENU_INT_EXIT = DIAG_EXIT_MENU,
};

/* Enable/Disable interrupts menu */
static void MenuInterrupts(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, dwIntOptions;
    BOOL fIntEnable, fIsMsi;

    dwIntOptions = WDC_GET_INT_OPTIONS(hDev);
    fIsMsi = WDC_INT_IS_MSI(dwIntOptions);
    if (dwIntOptions & INTERRUPT_LEVEL_SENSITIVE)
    {
        // TODO: You can remove this message after you have modified the
        //  implementation of MY_DRIVER_IntEnable() in my_driver_lib.c to
        //  correctly acknowledge level-sensitive interrupts (see guidelines
        //  in MY_DRIVER_IntEnable())
        printf("\n");
        printf("WARNING!!!\n");
        printf("----------\n");
        printf("Your hardware has level sensitive interrupts.\n");
        printf("Before enabling the interrupts, %s first modify the source "
            "code of MY_DRIVER_IntEnable(), in the file my_driver_lib.c, to "
            "\ncorrectly acknowledge%s interrupts",
            fIsMsi ? "it's recommended that you" : "you must",
            fIsMsi ? "level sensitive" : "");
        printf("when they occur (as dictated by the hardware's specifications).\n");
    }

    do
    {
        fIntEnable = !MY_DRIVER_IntIsEnabled(hDev);

        printf("\n");
        printf("Interrupts\n");
        printf("-----------\n");
        printf("%d. %s interrupts\n", MENU_INT_ENABLE_DISABLE,
            fIntEnable ? "Enable" : "Disable");
        printf("%d. Exit menu\n", MENU_INT_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_INT_ENABLE_DISABLE))
        {
            continue;
        }

        switch (option)
        {
        case MENU_INT_EXIT: /* Exit menu */
            break;
        case MENU_INT_ENABLE_DISABLE: /* Enable/disable interrupts */
            if (fIntEnable)
            {
                DWORD dwStatus = MY_DRIVER_IntEnable(hDev, DiagIntHandler);

                if (WD_STATUS_SUCCESS == dwStatus)
                {
                    printf("Interrupts enabled\n");
                }
                else
                {
                    MY_DRIVER_ERR("Failed enabling interrupts. Error [0x%lx - %s]\n",
                        dwStatus, Stat2Str(dwStatus));
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == MY_DRIVER_IntDisable(hDev))
                {
                    printf("Interrupts disabled\n");
                }
                else
                {
                    MY_DRIVER_ERR("Failed disabling interrupts: %s",
                        MY_DRIVER_GetLastErr());
                }
            }
            break;
        }
    } while (MENU_INT_EXIT != option);
}

/* Diagnostics interrupt handler routine */
static void DiagIntHandler(WDC_DEVICE_HANDLE hDev, MY_DRIVER_INT_RESULT* pIntResult)
{
    /* TODO: You can modify this function in order to implement your own
             diagnostics interrupt handler routine */

    printf("Got interrupt number %ld\n", pIntResult->dwCounter);
    printf("Interrupt Type: %s\n",
        WDC_DIAG_IntTypeDescriptionGet(pIntResult->dwEnabledIntType));
    if (WDC_INT_IS_MSI(pIntResult->dwEnabledIntType))
        printf("Message Data: 0x%lx\n", pIntResult->dwLastMessage);
}
/* -----------------------------------------------
    DMA memory handling
   ----------------------------------------------- */
   /* DMA menu options */
enum {
    MENU_DMA_ALLOCATE_CONTIG = 1,
    MENU_DMA_ALLOCATE_SG,
    MENU_DMA_RESERVED_MEM,
    MENU_DMA_SHARE_CONTIG_BUF,
    MENU_DMA_FREE_MEM,
    MENU_DMA_EXIT = DIAG_EXIT_MENU,
};

static void FreeDmaMem(PVOID* ppBuf, WD_DMA** ppDma)
{
    DWORD dwStatus;
    BOOL fIsSG; /* Is Scatter Gather DMA */

    if (!(*ppDma))
        return;

    fIsSG = !((*ppDma)->dwOptions & DMA_KERNEL_BUFFER_ALLOC);

    dwStatus = WDC_DMABufUnlock(*ppDma);
    if (WD_STATUS_SUCCESS == dwStatus)
    {
        printf("DMA memory freed\n");
    }
    else
    {
        MY_DRIVER_ERR("Failed trying to free DMA memory. Error [0x%lx - %s]\n",
            dwStatus, Stat2Str(dwStatus));
    }

    if (fIsSG)
        free(*ppBuf);

    *ppBuf = NULL;
    *ppDma = NULL;
}

/* Allocate/free DMA memory menu */
static void MenuDma(WDC_DEVICE_HANDLE hDev)
{
    DWORD option, size, dwStatus, dwOptions = 0;
    UINT64 qwAddr;
    PVOID pBuf = NULL;
    WD_DMA* pDma = NULL;
    DWORD dwDmaAddressWidth = 0;
    BOOL fIsSpecifyBitsSupported = TRUE;

#ifdef WIN32
    WD_OS_INFO OSinfo = get_os_type();

    /* Windows 8 and higher */
    fIsSpecifyBitsSupported = (OSinfo.dwMajorVersion >= 10) ||
        (OSinfo.dwMajorVersion == 6 && OSinfo.dwMinorVersion >= 2);
#endif

    do
    {
        printf("\n");
        printf("DMA memory\n");
        printf("-----------\n");
        printf("%d. Allocate contiguous memory\n", MENU_DMA_ALLOCATE_CONTIG);
        printf("%d. Allocate scatter-gather memory\n", MENU_DMA_ALLOCATE_SG);
        printf("%d. Use reserved memory\n", MENU_DMA_RESERVED_MEM);
        if (pDma && pDma->dwOptions & DMA_KERNEL_BUFFER_ALLOC)
        {
            printf("%d. Send buffer through IPC to all group processes\n",
                MENU_DMA_SHARE_CONTIG_BUF);
        }
        printf("%d. Free DMA memory\n", MENU_DMA_FREE_MEM);
        printf("%d. Exit menu\n", MENU_DMA_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option, MENU_DMA_FREE_MEM))
            continue;

        if (option == MENU_DMA_RESERVED_MEM)
        {
#ifdef WIN32
            printf("Warning: The address for the reserved memory should be "
                "calculated according to the values listed in registry key\n"
                "HKLM/HARDWARE/RESOURCEMAP/System Resources/Physical Memory.\n"
                "Any other address may result in a BSOD. For more details "
                "please refer to Tech Doc #129\n\n");
#endif
            sprintf(gsInput, "Enter reserved memory address "
                "(64 bit hex uint) ");
            qwAddr = 0;
            if (DIAG_INPUT_SUCCESS != DIAG_InputUINT64(&qwAddr, gsInput, TRUE,
                1, 0xFFFFFFFFFFFFFFFF))
            {
                continue;
            }
        }

        if (option == MENU_DMA_ALLOCATE_CONTIG ||
            option == MENU_DMA_ALLOCATE_SG ||
            option == MENU_DMA_RESERVED_MEM)
        {
            sprintf(gsInput, "Enter memory allocation size in bytes "
                "(32 bit uint) ");
            size = 0;
            if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD((PVOID)&size, gsInput,
                FALSE, 1, 0xFFFFFFFF))
            {
                continue;
            }
            if (option == MENU_DMA_ALLOCATE_CONTIG && fIsSpecifyBitsSupported)
            {
                sprintf(gsInput, "Enter DMA address width of an address "
                    "that your device supports, use 0 for default value "
                    "(32 bit uint)");
                if (DIAG_INPUT_SUCCESS != DIAG_InputDWORD(
                    (PVOID)&dwDmaAddressWidth, gsInput, FALSE, 0, 64))
                {
                    continue;
                }

                dwOptions = DMA_KBUF_ALLOC_SPECIFY_ADDRESS_WIDTH |
                    (dwDmaAddressWidth << DMA_OPTIONS_ADDRESS_WIDTH_SHIFT);
            }

            /* Free DMA memory before trying the new allocation */
            FreeDmaMem(&pBuf, &pDma);
        }

        switch (option)
        {
        case MENU_DMA_ALLOCATE_CONTIG: /* Allocate contiguous memory */
            dwStatus = WDC_DMAContigBufLock(hDev, &pBuf, dwOptions, size,
                &pDma);
            if (WD_STATUS_SUCCESS == dwStatus)
            {
                printf("Contiguous memory allocated. user addr [%p], "
                    "physical addr [0x%"PRI64"x], size [%lu(0x%lx)]\n", pBuf,
                    pDma->Page[0].pPhysicalAddr, pDma->Page[0].dwBytes,
                    pDma->Page[0].dwBytes);
            }
            else
            {
                MY_DRIVER_ERR("Failed allocating contiguous memory. size [%lu], "
                    "Error [0x%lx - %s]\n", size, dwStatus, Stat2Str(dwStatus));
            }
            break;

        case MENU_DMA_ALLOCATE_SG: /* Allocate scatter-gather memory */
            pBuf = malloc(size);
            if (!pBuf)
            {
                MY_DRIVER_ERR("Failed allocating user memory for SG. size [%ld]\n",
                    size);
                continue;
            }

            dwStatus = WDC_DMASGBufLock(hDev, pBuf, 0 /* dwOptions */, size,
                &pDma);
            if (WD_STATUS_SUCCESS == dwStatus)
            {
                DWORD i;

                printf("SG memory allocated. user addr [%p], size [%ld]\n",
                    pBuf, size);

                printf("Pages physical addresses:\n");
                for (i = 0; i < pDma->dwPages; i++)
                {
                    printf("%lu) physical addr [0x%"PRI64"x], "
                        "size [%ld(0x%lx)]\n", i + 1,
                        pDma->Page[i].pPhysicalAddr, pDma->Page[i].dwBytes,
                        pDma->Page[i].dwBytes);
                }
            }
            else
            {
                MY_DRIVER_ERR("Failed allocating SG memory. size [%ld], "
                    "Error [0x%lx - %s]\n", size, dwStatus, Stat2Str(dwStatus));
                free(pBuf);
            }
            break;

        case MENU_DMA_RESERVED_MEM:
            dwStatus = WDC_DMAReservedBufLock(hDev, qwAddr, &pBuf,
                0 /* dwOptions */, size, &pDma);
            if (WD_STATUS_SUCCESS == dwStatus)
            {
                printf("Reserved memory claimed. user addr [%p], "
                    "bus addr [0x%"PRI64"x], size [%ld(0x%lx)]\n", pBuf,
                    pDma->Page[0].pPhysicalAddr, pDma->Page[0].dwBytes,
                    pDma->Page[0].dwBytes);
            }
            else
            {
                MY_DRIVER_ERR("Failed claiming reserved memory. size [%ld], "
                    "Error [0x%lx - %s]\n", size, dwStatus, Stat2Str(dwStatus));
            }
            break;

        case MENU_DMA_SHARE_CONTIG_BUF:
            WDS_DIAG_IpcSendDmaContigToGroup(pDma);
            break;
        case MENU_DMA_FREE_MEM: /* Free DMA memory */
            FreeDmaMem(&pBuf, &pDma);
            break;
        }
    } while (MENU_DMA_EXIT != option);

    /* Free DMA memory before exiting */
    FreeDmaMem(&pBuf, &pDma);
}

/* ----------------------------------------------------
    Plug-and-play and power management events handling
   ---------------------------------------------------- */
   /* Events menu options */
enum {
    MENU_EVENTS_REGISTER_UNREGISTER = 1,
    MENU_EVENTS_EXIT = DIAG_EXIT_MENU,
};

/* Register/unregister plug-and-play and power management events menu */
static void MenuEvents(WDC_DEVICE_HANDLE hDev)
{
    DWORD option;
    BOOL fRegister;

    do
    {
        fRegister = !MY_DRIVER_EventIsRegistered(hDev);

        printf("\n");
        printf("Plug-and-play and power management events\n");
        printf("------------------------------------------\n");
        printf("%d. %s events\n", MENU_EVENTS_REGISTER_UNREGISTER,
            fRegister ? "Register" : "Unregister");
        printf("%d. Exit menu\n", MENU_EVENTS_EXIT);
        printf("\n");

        if (DIAG_INPUT_FAIL == DIAG_GetMenuOption(&option,
            MENU_EVENTS_REGISTER_UNREGISTER))
        {
            continue;
        }

        switch (option)
        {
        case MENU_EVENTS_EXIT: /* Exit menu */
            break;
        case MENU_EVENTS_REGISTER_UNREGISTER: /* Register/unregister events */
            if (fRegister)
            {
                if (WD_STATUS_SUCCESS == MY_DRIVER_EventRegister(hDev,
                    DiagEventHandler))
                {
                    printf("Events registered\n");
                }
                else
                {
                    MY_DRIVER_ERR("Failed to register events. Last error [%s]",
                        MY_DRIVER_GetLastErr());
                }
            }
            else
            {
                if (WD_STATUS_SUCCESS == MY_DRIVER_EventUnregister(hDev))
                {
                    printf("Events unregistered\n");
                }
                else
                {
                    MY_DRIVER_ERR("Failed to unregister events. Last error [%s]",
                        MY_DRIVER_GetLastErr());
                }
            }
            break;
        }
    } while (MENU_EVENTS_EXIT != option);
}

/* Diagnostics plug-and-play and power management events handler routine */
static void DiagEventHandler(WDC_DEVICE_HANDLE hDev, DWORD dwAction)
{
    /* TODO: You can modify this function in order to implement your own
     *       diagnostics events handler routine. */

    printf("\nReceived event notification (device handle 0x%p): ", hDev);
    switch (dwAction)
    {
    case WD_INSERT:
        printf("WD_INSERT\n");
        break;
    case WD_REMOVE:
        printf("WD_REMOVE\n");
        break;
    case WD_POWER_CHANGED_D0:
        printf("WD_POWER_CHANGED_D0\n");
        break;
    case WD_POWER_CHANGED_D1:
        printf("WD_POWER_CHANGED_D1\n");
        break;
    case WD_POWER_CHANGED_D2:
        printf("WD_POWER_CHANGED_D2\n");
        break;
    case WD_POWER_CHANGED_D3:
        printf("WD_POWER_CHANGED_D3\n");
        break;
    case WD_POWER_SYSTEM_WORKING:
        printf("WD_POWER_SYSTEM_WORKING\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING1:
        printf("WD_POWER_SYSTEM_SLEEPING1\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING2:
        printf("WD_POWER_SYSTEM_SLEEPING2\n");
        break;
    case WD_POWER_SYSTEM_SLEEPING3:
        printf("WD_POWER_SYSTEM_SLEEPING3\n");
        break;
    case WD_POWER_SYSTEM_HIBERNATE:
        printf("WD_POWER_SYSTEM_HIBERNATE\n");
        break;
    case WD_POWER_SYSTEM_SHUTDOWN:
        printf("WD_POWER_SYSTEM_SHUTDOWN\n");
        break;
    default:
        printf("0x%lx\n", dwAction);
        break;
    }
}


